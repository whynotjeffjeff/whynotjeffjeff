---
title: 计算机组成原理·指令系统
date: 2021-04-06 12:01:51
type: "计算机组成原理"
comments: false
top_img: false
---


# 指令系统
## 指令系统
是指令集体系结构ISA的核心  
ISA主要包括：
- 指令格式
- 数据类型及格式
- 操作数的存放方式
- 程序可访问的寄存器个数、位数和编号 
- 存储空间大小和编址方式
- 寻址方式
- 指令执行过程的控制方式等
### 指令的基本格式
一条指令包括操作码和地址码字段
|||
|-|-|
|操作码|地址码|

操作码:
- 指出指令应执行的操作
- 识别指令
- 了解指令功能
- 区分操作数地址内容的组成和使用方法  

地址码：
- 给出被操作的信息的地址
- 参加运算的一个或多个操作数所在的地址
- 运算结果的保存地址
- 程序的转移地址
- 被调用的子程序的入口地址等

指令长度是指一条指令中包含的二进制代码的位数  
指令字长取决于
- 操作码的长度
- 操作数地址码的长度
- 操作数地址个数  

单字长指令：等于机器字长  
半字长指令：一半机器字长  
双字长指令：二倍机器字长  
定长指令字结构：一个指令系统所有指令的长度都是相等的  

#### 零地址指令：无显示地址

||
|-|
|OP|

- 不需要操作数的指令
- 零地址运算指令仅用于堆栈计算机，通常参与运算的两个操作数隐含的从栈顶和次栈顶弹出，送至运算器，运算结果再隐含的压入堆栈  

一地址指令：

|||
|-|-|
|OP|$A_1$|

OP($A_1$) $\to$ $A_1$
- 只有目的操作数，按$A_1$地址读取操作数，进行OP操作后，结果存回原地址  

(ACC)OP($A_1$) $\to$ ACC
- 隐含约定目的地址的双操作数指令，按指令地址$A_1$地址读取操作数，指令可隐含约定另一个操作数由ACC提供，运算结果也将存放在ACC中
- 若指令长度为32位，操作码占8位，1个地址码字段占24位，指令操作数直接寻址范围$2^{24}=16M$

#### 二地址指令
||||
|-|-|-|
|OP|$A_1$|$A_2$|

($A_1$)OP($A_2$) $\to$ $A_1$

- 常用的算术和逻辑运算指令，需要两个操作数，需要分别给出目的操作数和源操作数，其中目的操作数地址还用于存放本次运算结果
- 指令字长位32位，操作码占8位，两个地址码各占12位，则指令操作数的直接寻址范围$2^{12}=4K$

#### 三地址指令
|||||
|-|-|-|-|
|OP|$A_1$|$A_2$|$A_3$(结果)|

($A_1$)OP($A_2$) $\to$ $A_3$

- 指令字长位32位，操作码占8位，3个地址码各占8位，直接寻址范围$2^8=256$，地址字段为主存地址，则完成一条三地址需要4次访存，取指令1次，取两个操作数2次，存放结果1次

#### 四地址指令

||||||
|-|-|-|-|-|
|OP|$A_1$|$A_2$|$A_3$|$A_4$|

($A_1$)OP($A_2$) $\to$ $A_3$ ，$A_4$ = 下一条执行指令的地址

- 地址字长为32位，操作码占8位，4个地址码各占6位，直接寻址范围$2^6=64$

### 定长操作码指令格式
在指令字的最高位部分分配固定的若干位（定长）表示操作码。
n位操作码字段的指令系统最大能表示$2^{n}$条指令

### 扩展操作码指令格式
- 不允许短码是长码的前缀
- 各指令的操作码一定不能重复

|||||
|-|-|-|-|
|0000|0001|0010|0011|
|0100|0101|0110|0111|
|1000|1001|1010|1011|
|1100|1101|1110|1111|

|||||||
|-|-|-|-|-|-|
|操作码情况|OP|$A_1$|$A_2$|$A_3$|说明|
|15条三地址|0000-1110||||余出16-15=1，1*2^4=16种|
|12条二地址|1111|0000-1011|||余出16-12=4，4*2^4=64种|
|62条一地址|1111|(1100-1110)/1111|(0000-1111)/(0000-1101)||余出64-62=2，2*2^4=32种|
|32条零地址|1111|1111|1110-1111|0000-1111||

### 指令的操作类型
- 数据传送
- 算术和逻辑运算
- 移位
- 转移
- 输入输出

## 指令寻址方式
确定本条指令的数据地址以及下一条待执行指令的地址，分为：
- 指令寻址：寻找下条要执行的指令  
（1）顺序寻址  
通过PC+(1)，自动形成下一条指令  
（2）跳跃寻址  
通过转移指令实现，下条指令的地址不由PC自动给出，而由本条指令给出下条指令地址的计算方式。是否可跳跃受到状态寄存器和操作数的控制，跳跃的结果是当前指令修改PC值，下一条指令仍通过PC给出

- 数据寻址：寻找本条指令的数据  
通常在指令字中设一个字段指明寻址方式

    ||||
    |-|-|-|
    |操作码|寻址特征|形式地址A|

### 常见数据寻址方式

#### 隐含寻址
不明显的给出操作数，在指令中隐含操作数地址
- 优：有利于缩短指令字长
- 缺：需要增加存储操作数或隐含地址的硬件

#### 立即（数）寻址
指令的地址字段指出的不是操作数地址，而是操作数本身，又称立即数，#表示立即寻址特征，使用补码表示
- 优：指令在执行阶段不访问主存，指令执行时间最短
- 缺：A的位数限制立即数的范围

#### 直接寻址
指令中的形式地址A是操作数的真实地址EA，EA=A  
- 优：简单，访存1次，不需要专门计算操作数的地址
- 缺：A的位数决定了指令操作数的寻址范围，操作数的地址不易修改

#### 间接寻址
指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址的存储单元地址，EA=(A)，间接寻址可以迭代多次  
间接寻址，主存第一位表示是否为多次间址
- 优：可扩大寻址范围（有效地址EA的位数大于形式地址A的位数），便于编制程序（用间址寻址可方便的完成子程序返回）
- 缺：访问速度慢

#### 寄存器寻址
指令字中直接给出操作数所在的寄存器编号EA= $R_i$，操作数在由$R_i$所指的寄存器内
- 优：指令执行阶段不访存，只访问寄存器，寄存器对应地址码长度较小，使得指令字短且因不用访存，所以执行速度快，支持向量/矩阵运算
- 缺:寄存器昂贵，有限

#### 寄存器间接寻址
寄存器$R_i$中给出的不是一个操作数，而是操作数所在主存单元的地址EA=($R_i$)
- 优：与一般间址寻址速度快
- 缺：需要访存

#### 相对寻址
PC的内容加上指令格式的形式地址A而形成操作数的有效地址EA=(PC)+A，A是相对于当前PC的值的位移量，可正可负，用补码表示，A的位数决定寻址范围
- 操作数的地址是不固定的，随PC的值变化而变化，且与指令地址之间相差一个固定值，便于程序浮动，广泛用于转移指令
- JMP A，CPU从存储器取出一字节，自动执行(PC)+1 $\to$ PC，若转移指令的地址为X，且占2B，取出该指令后，PC自增2，(PC)=X+2，执行完该指令，会自动跳转至X+2+A的地址继续执行

#### 基址寻址
将CPU的基址寄存器BR的内容加上指令格式的形式地址A形成操作数的有效地址EA=(BR)+A，基址寄存器可采用专用寄存器也可为通用寄存器
- 基址寄存器面向操作系统，内容通过操作系统或管理程序确定，主要用于解决程序逻辑空间与存储器物理空间的无关性
- 执行过程中基址寄存器内容不变，形式地址可变（偏移量）
- 采用通用寄存器作为基址寄存器，用户可决定使用哪个寄存器，内容由操作系统确定

- 优：可扩大寻址范围（基址寄存器位数大于形式地址A的位数），用户不必考虑自己的程序存于主存哪个区域，有利于多道程序设计，可用于制成浮动程序
- 缺：偏移量位数较短

#### 变址寻址
有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容之和，EA=(IX)+A
- IX可使用专用寄存器或通用寄存器
- 变址寄存器面向用户，在程序执行过程，变址寄存器内容可由用户改变（作为偏移量），形式地址A不变（作为基地址）
- 可扩大寻址范围（变址寄存器位数大于形式地址A的位数），适合编制循环程序，偏移量的位数（IX）足以表示整个存储空间

#### 堆栈寻址
堆栈是存储器（或专用寄存器组）中一块特定的、按照后进先出（LIFO）的原则管理的存储区，存储区读写单元地址是用一个特定寄存器给出的称为堆栈指针(SP)，分为硬堆栈（不适合做大容量堆栈）和软堆栈（主存划出一段区域）

|寻址方式|有效地址|访存次数|
|-|-|-|
|隐含寻址|程序指定|0|
|立即寻址|A是操作数|0|
|直接寻址|EA=A|1|
|一次间接寻址|EA=(A)|2|
|寄存器寻址|EA= $R_i$|0|
|寄存器间接一次寻址|EA = ($R_i$)|1|
|相对寻址|EA=(PC)+A|1|
|基址寻址|EA=(BR)+A|1|
|变址寻址|EA=(IX)+A|1|